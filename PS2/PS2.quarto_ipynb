{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "name: Mahnoor Arif\n",
        "title: \"PS2\"\n",
        "format: html\n",
        "---"
      ],
      "id": "e2b58c64"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd"
      ],
      "id": "be7bdd00",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "tickets_data = pd.read_csv('C:\\\\Users\\\\arifm\\\\OneDrive\\\\Documents\\\\GitHub\\\\student30538\\\\PS2\\\\parking_tickets_one_percent.csv')"
      ],
      "id": "f9fb6543",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "!pip install altair_saver"
      ],
      "id": "ef6a13cd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##Data cleaning continued (15 points)\n"
      ],
      "id": "e89f042b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#Q1\n",
        "# Step 2: Define a function to count NAs for each column\n",
        "def count_na_per_column(dataframe):\n",
        "    # Create a dictionary where keys are column names and values are the number of NAs\n",
        "    na_counts = dataframe.isna().sum()\n",
        "    \n",
        "    # Convert the result to a DataFrame called countNA\n",
        "    na_df = pd.DataFrame({\n",
        "        'Variable': na_counts.index,   # Column names\n",
        "        'NA_Count': na_counts.values   # NA counts\n",
        "    })\n",
        "    \n",
        "    return na_df\n",
        "\n",
        "# Step 3: Apply the function to the parking tickets data frame\n",
        "na_report = count_na_per_column(tickets_data)\n",
        "\n",
        "# Step 4: Print the results\n",
        "print(na_report)\n",
        "\n",
        "# Optional: Save the result to a CSV file\n",
        "na_report.to_csv('na_counts_report.csv', index=False)"
      ],
      "id": "c01502e4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#Q2\n",
        "#The three variables with most missing values include: notice_level, hearing_disposition and zip_code##  "
      ],
      "id": "ca53ff98",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#1.3\n",
        "## New code: 0964125B\n",
        "## old code: 0964125"
      ],
      "id": "3062921f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#1.4\n"
      ],
      "id": "cccf11e3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#NO CITY STICKER OR IMPROPER DISPLAY\t$ 120\n",
        "\n",
        "#NO CITY STICKER VEHICLE UNDER/EQUAL TO 16,000 LBS.\t$200"
      ],
      "id": "1c9e37c9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "##2.1\n",
        "import pandas as pd\n",
        "import altair as alt\n",
        "\n",
        "# Ensure issue_date is in datetime format\n",
        "tickets_data['issue_date'] = pd.to_datetime(tickets_data['issue_date'])\n",
        "\n",
        "# Combine the two violation codes by creating a new column 'city_sticker_violation'\n",
        "old_code = '0964125'\n",
        "new_code = '0964125B'\n",
        "\n",
        "tickets_data['city_sticker_violation'] = tickets_data['violation_code'].isin([old_code, new_code])\n",
        "\n",
        "# Filter data for city sticker violations and group by month, include only dates up to 2018\n",
        "filtered_data = tickets_data[(tickets_data['city_sticker_violation']) & \n",
        "                             (tickets_data['issue_date'] <= '2018-12-31')]  # Correctly closed string literal\n",
        "\n",
        "# Group by month for city sticker violations\n",
        "df_monthly = filtered_data.groupby(filtered_data['issue_date'].dt.to_period('M')).size().reset_index(name='ticket_count')\n",
        "\n",
        "# Convert the period back to a timestamp for plotting\n",
        "df_monthly['issue_date'] = df_monthly['issue_date'].dt.to_timestamp()\n",
        "\n",
        "# Plot the number of tickets over time using Altair\n",
        "chart = alt.Chart(df_monthly).mark_line().encode(\n",
        "    x='issue_date:T', \n",
        "    y='ticket_count'\n",
        ").properties(\n",
        "    title='Missing City Sticker Tickets (Up to 2018)'\n",
        ")\n",
        "\n",
        "chart.display()\n",
        "chart.save('monthly_tickets_chart.html')  # Save as HTML"
      ],
      "id": "7b512b45",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "##2.2\n",
        "import pandas as pd\n",
        "import altair as alt\n",
        "\n",
        "# Ensure issue_date is in datetime format\n",
        "tickets_data['issue_date'] = pd.to_datetime(tickets_data['issue_date'])\n",
        "\n",
        "# Combine the two violation codes\n",
        "old_code = '0964125'\n",
        "new_code = '0964125B'\n",
        "tickets_data['city_sticker_violation'] = tickets_data['violation_code'].isin([old_code, new_code])\n",
        "\n",
        "# Filter data for city sticker violations and group by month, include only dates up to 2018\n",
        "filtered_data = tickets_data[(tickets_data['city_sticker_violation']) & \n",
        "                             (tickets_data['issue_date'] <= '2018-12-31')]\n",
        "\n",
        "# Group by month for city sticker violations\n",
        "df_monthly = filtered_data.groupby(filtered_data['issue_date'].dt.to_period('M')).size().reset_index(name='ticket_count')\n",
        "\n",
        "# Convert the period back to a timestamp for plotting\n",
        "df_monthly['issue_date'] = df_monthly['issue_date'].dt.to_timestamp()\n",
        "\n",
        "# Plot the number of tickets over time and add custom date labels\n",
        "price_increase_date = '2017-06-01'  # Example date of price increase, adjust accordingly\n",
        "\n",
        "chart = alt.Chart(df_monthly).mark_line().encode(\n",
        "    x=alt.X('issue_date:T', axis=alt.Axis(format='%Y-%m', labelAngle=-45)),  # Custom date format\n",
        "    y='ticket_count'\n",
        ").properties(\n",
        "    title='Missing City Sticker Tickets Over Time'\n",
        ")\n",
        "\n",
        "# Add a vertical line to indicate the price increase date\n",
        "rule = alt.Chart(pd.DataFrame({'price_increase': [price_increase_date]})).mark_rule(color='red').encode(\n",
        "    x='price_increase:T'\n",
        ")\n",
        "\n",
        "# Combine the line chart and the rule\n",
        "final_chart = chart + rule\n",
        "\n",
        "final_chart.display()"
      ],
      "id": "304aa46e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "##3.1\n",
        "# Create DataFrame\n",
        "# Get the top 10 violations based on total tickets\n",
        "top_10_violations = violation_df.nlargest(10, 'total_tickets')['violation_description'].tolist()\n",
        "\n",
        "# Create a new column to label violations\n",
        "violation_df['label'] = violation_df['violation_description'].apply(\n",
        "    lambda x: x if x in top_10_violations else 'Other'\n",
        ")\n"
      ],
      "id": "24a6d6e7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import altair as alt\n",
        "\n",
        "# Scatter plot for top 10 violations and \"Other\"\n",
        "scatter_top_10 = alt.Chart(violation_df).mark_point().encode(\n",
        "    x='paid_fine:Q',\n",
        "    y='unpaid_fine:Q',\n",
        "    color='label:N',\n",
        "    tooltip=['violation_description:N', 'paid_fine:Q', 'unpaid_fine:Q']\n",
        ").properties(\n",
        "    title='Scatter Plot of Paid Fine vs Unpaid Fine with Top Violations'\n",
        ")\n",
        "\n",
        "# Adding text labels for the top 10 violations\n",
        "text_labels = scatter_top_10.mark_text(\n",
        "    align='left',\n",
        "    dx=5,\n",
        "    dy=-5\n",
        ").encode(\n",
        "    text='label:N'\n",
        ")\n",
        "\n",
        "# Combine the scatter plot with text labels\n",
        "combined_top_10_chart = scatter_top_10 + text_labels\n",
        "combined_top_10_chart.show()"
      ],
      "id": "973972d4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Define categories for violations\n",
        "def categorize_violation(description):\n",
        "    if \"PARKING\" in description:\n",
        "        return \"Parking Violations\"\n",
        "    elif \"SPEED\" in description:\n",
        "        return \"Speed Violations\"\n",
        "    elif \"ALARM\" in description:\n",
        "        return \"Alarm Violations\"\n",
        "    elif \"HYDRANT\" in description:\n",
        "        return \"Fire Hydrant Violations\"\n",
        "    elif \"CROSSWALK\" in description:\n",
        "        return \"Crosswalk Violations\"\n",
        "    else:\n",
        "        return \"Other Violations\"\n",
        "\n",
        "# Create a new column for categories\n",
        "violation_df['category'] = violation_df['violation_description'].apply(categorize_violation)\n",
        "\n",
        "# Check if categorization is correct\n",
        "print(violation_df[['violation_description', 'category']].head(15))\n",
        "\n",
        "# Scatter plot with categories for violations\n",
        "scatter_categories = alt.Chart(violation_df).mark_point().encode(\n",
        "    x='paid_fine:Q',\n",
        "    y='unpaid_fine:Q',\n",
        "    color='category:N',\n",
        "    tooltip=['violation_description:N', 'paid_fine:Q', 'unpaid_fine:Q']\n",
        ").properties(\n",
        "    title='Scatter Plot of Paid Fine vs Unpaid Fine by Category'\n",
        ")\n",
        "\n",
        "# Adding text labels for categories\n",
        "text_labels_categories = scatter_categories.mark_text(\n",
        "    align='left',\n",
        "    dx=5,\n",
        "    dy=-5\n",
        ").encode(\n",
        "    text='category:N'\n",
        ")\n",
        "\n",
        "# Combine the scatter plot with text labels\n",
        "combined_categories_chart = scatter_categories + text_labels_categories\n",
        "combined_categories_chart.show()"
      ],
      "id": "4e75310b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "##3.2\n",
        "import pandas as pd\n",
        "\n",
        "# Sample data: replace with your actual DataFrame\n",
        "# tickets_data = pd.read_csv('path_to_your_data.csv')\n",
        "\n",
        "# Create DataFrame\n",
        "violation_df = tickets_data.groupby('violation_description').agg(\n",
        "    repayment_rate=('ticket_queue', lambda x: (x == 'Paid').sum() / len(x)),\n",
        "    avg_fine=('fine_level1_amount', 'mean'),\n",
        "    total_tickets=('ticket_number', 'count')\n",
        ").reset_index()\n",
        "\n",
        "# Filter for violations that appear at least 100 times\n",
        "violation_df = violation_df[violation_df['total_tickets'] >= 100]\n",
        "\n",
        "# Sort by total tickets\n",
        "violation_df = violation_df.sort_values(by='violation_description', ascending=False)\n",
        "\n",
        "# Print the top 5 violations\n",
        "print(violation_df.head(5))"
      ],
      "id": "ff0f592f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "##creating scatter plot\n",
        "import altair as alt\n",
        "\n",
        "# Identify and exclude the outlier (if necessary)\n",
        "# For demonstration, let's assume we exclude any fine greater than a specific threshold\n",
        "fine_threshold = violation_df['avg_fine'].quantile(0.95)  # Example threshold\n",
        "violation_df_filtered = violation_df[violation_df['avg_fine'] <= fine_threshold]\n",
        "\n",
        "# Scatter plot\n",
        "scatter_plot = alt.Chart(violation_df_filtered).mark_circle(size=60).encode(\n",
        "    x='avg_fine:Q',\n",
        "    y='repayment_rate:Q',\n",
        "    tooltip=['violation_description:N', 'avg_fine:Q', 'repayment_rate:Q']\n",
        ").properties(\n",
        "    title='Relationship Between Fine Amount and Repayment Rate'\n",
        ")\n",
        "\n",
        "scatter_plot.show()"
      ],
      "id": "9cf80d94",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Bar chart to show avg_fine vs. repayment_rate\n",
        "bar_chart = alt.Chart(violation_df_filtered).mark_bar().encode(\n",
        "    x='violation_description:N',\n",
        "    y='repayment_rate:Q',\n",
        "    color='avg_fine:Q',\n",
        "    tooltip=['violation_description:N', 'avg_fine:Q', 'repayment_rate:Q']\n",
        ").properties(\n",
        "    title='Repayment Rate by Violation Type'\n",
        ").transform_filter(\n",
        "    alt.datum.repayment_rate > 0  # Exclude any violations with 0 repayment rate\n",
        ")\n",
        "\n",
        "bar_chart.show()"
      ],
      "id": "6084894b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Group by avg_fine and calculate the mean repayment rate\n",
        "mean_repayment = violation_df_filtered.groupby('avg_fine').agg(\n",
        "    avg_repayment_rate=('repayment_rate', 'mean')\n",
        ").reset_index()\n",
        "\n",
        "# Line chart to show the trend of avg_fine vs. mean repayment_rate\n",
        "line_chart = alt.Chart(mean_repayment).mark_line().encode(\n",
        "    x='avg_fine:Q',\n",
        "    y='avg_repayment_rate:Q',\n",
        "    tooltip=['avg_fine:Q', 'avg_repayment_rate:Q']\n",
        ").properties(\n",
        "    title='Trend of Mean Repayment Rate with Average Fine Amount'\n",
        ")\n",
        "\n",
        "line_chart.show()\n"
      ],
      "id": "73418a50",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#4.1\n",
        "import pandas as pd\n",
        "\n",
        "# Sample data loading\n",
        "# tickets_data = pd.read_csv('path_to_your_data.csv')\n",
        "\n",
        "# Create DataFrame for violations with at least 100 citations\n",
        "violation_df = tickets_data.groupby('violation_description').agg(\n",
        "    total_tickets=('ticket_number', 'count'),\n",
        "    paid_fine=('fine_level1_amount', lambda x: x[tickets_data['ticket_queue'] == 'Paid'].mean()),\n",
        "    unpaid_fine=('fine_level1_amount', lambda x: x[tickets_data['ticket_queue'] != 'Paid'].mean())\n",
        ").reset_index()\n",
        "\n",
        "# Filter for violations with at least 100 citations\n",
        "violation_df = violation_df[violation_df['total_tickets'] >= 100]\n",
        "\n",
        "# Calculate if the fine doubles and the increase in amount\n",
        "violation_df['fine_doubles'] = violation_df['unpaid_fine'] == 2 * violation_df['paid_fine']\n",
        "violation_df['increase_if_unpaid'] = violation_df['unpaid_fine'] - violation_df['paid_fine']\n",
        "\n",
        "# Find violations that do not double in price\n",
        "non_doubling_violations = violation_df[~violation_df['fine_doubles']]\n",
        "\n",
        "# Display results\n",
        "print(non_doubling_violations[['violation_description', 'paid_fine', 'unpaid_fine', 'increase_if_unpaid']])"
      ],
      "id": "1559ce3a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "##Explanation for 4.1\n",
        "##Negative Increases:\n",
        "\n",
        "##For some violations (e.g., 20' OF CROSSWALK), the increase_if_unpaid is negative, meaning that the unpaid fine is lower than the paid fine by about $1.29. This is unusual since typically, one would expect unpaid fines to be at least equal to or greater than the paid fines.\n",
        "\n",
        "##Positive Increases:\n",
        "\n",
        "##Violations like TRUCK,RV,BUS, OR TAXI RESIDENTIAL STREET show a positive increase of about $6.17. This indicates that the fine for unpaid tickets is higher than that for paid tickets, which might suggest that certain violations have a small increase for unpaid tickets but do not double in price.\n",
        "\n",
        "##Not Doubling: Out of the 66 violations listed, none follow the typical doubling rule for unpaid tickets. Instead, many have either a slight increase, no increase, or even a decrease in the unpaid fine compared to the paid fine."
      ],
      "id": "07f28ecb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##4.2\n"
      ],
      "id": "6a51d3e8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#4.3\n",
        "\n",
        "# Get the top 10 violations based on total tickets\n",
        "top_10_violations = violation_df.nlargest(10, 'total_tickets')['violation_description'].tolist()\n",
        "\n",
        "# Create a new column to label violations\n",
        "violation_df['label'] = violation_df['violation_description'].apply(\n",
        "    lambda x: x if x in top_10_violations else 'Other'\n",
        ")\n",
        "##Scatter Plot\n",
        "import altair as alt\n",
        "\n",
        "# Scatter plot with labels for top 10 violations and \"Other\"\n",
        "scatter_top_10 = alt.Chart(violation_df).mark_point().encode(\n",
        "    x='avg_fine:Q',\n",
        "    y='repayment_rate:Q',\n",
        "    color='label:N',\n",
        "    tooltip=['violation_description:N', 'avg_fine:Q', 'repayment_rate:Q']\n",
        ").properties(\n",
        "    title='Scatter Plot of Avg Fine vs Repayment Rate with Top 10 Violations'\n",
        ")\n",
        "\n",
        "# Adding text labels for the top 10 violations\n",
        "text_labels = scatter_top_10.mark_text(\n",
        "    align='left',\n",
        "    dx=5,\n",
        "    dy=-5\n",
        ").encode(\n",
        "    text='label:N'\n",
        ")\n",
        "\n",
        "# Combine the scatter plot with text labels\n",
        "combined_top_10_chart = scatter_top_10 + text_labels\n",
        "combined_top_10_chart.show()"
      ],
      "id": "2032b7cd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "##BONUS QUESTION\n",
        "import pandas as pd\n",
        "\n",
        "# Assuming tickets_data is your original DataFrame\n",
        "# Create a DataFrame with necessary columns\n",
        "violation_data = tickets_data[['violation_code', 'violation_description']]\n",
        "\n",
        "# Group by violation_code and count unique violation_descriptions\n",
        "violation_summary = violation_data.groupby('violation_code').agg(\n",
        "    num_descriptions=('violation_description', 'nunique'),\n",
        "    most_common_description=('violation_description', lambda x: x.mode()[0]),\n",
        "    total_observations=('violation_description', 'count')\n",
        ").reset_index()\n",
        "\n",
        "# Filter for codes with multiple descriptions\n",
        "multiple_descriptions = violation_summary[violation_summary['num_descriptions'] > 1]\n",
        "\n",
        "# Print the three codes with the most observations\n",
        "top_three_codes = multiple_descriptions.nlargest(3, 'total_observations')\n",
        "print(top_three_codes[['violation_code', 'num_descriptions', 'most_common_description', 'total_observations']])"
      ],
      "id": "c3150874",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "___________________________\n"
      ],
      "id": "4fff1488"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\arifm\\AppData\\Roaming\\Python\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}